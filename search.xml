<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux mysql定时自动备份的实现</title>
    <url>/2021/03/03/backup/</url>
    <content><![CDATA[<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>基本上不管是对于我们自己使用，还是给客户部署服务器，mysql备份是不可或缺的一部分，这里就教大家怎么去实现mysql的定时自动备份功能，为了实现这个功能，也是踩了各种坑，最后整理出来的，在这里我们实现了下面这三个功能</p>
<span id="more"></span>
<ul>
<li>mysql_backup.sh 用于备份数据</li>
<li>mysql_restore.sh 用于恢复数据</li>
<li>remove_backup.sh 用于删除一段时间以前的备份文件</li>
</ul>
<p><code>  我是使用root用户操作的，如果用户组权限不够的话，需要 sudo 提权，这个就看大家自己的需要了  还需要大家具有 vi 的操作技能哦，如不会的话需要大家自行了解了，这里就不赘述了</code></p>
<h2 id="一、数据备份"><a href="#一、数据备份" class="headerlink" title="一、数据备份"></a>一、数据备份</h2><ol>
<li>创建备份目录<br>这里我选择了把备份文件放在 /data/backup/mysql下面，把脚本放在 /data/backup 下面<br>先创建文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;backup&#x2F;mysql </span><br><span class="line">cd &#x2F;data&#x2F;backup</span><br></pre></td></tr></table></figure></li>
<li>创建脚本文件<br>创建mysql_backup.sh<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi mysql_backup.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>粘贴下面的脚本内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">需要的话，自己改这里哦</span><br><span class="line">#db_user&#x3D;’root’</span><br><span class="line">#db_password&#x3D;cat &#x2F;data&#x2F;www&#x2F;mysql_password</span><br><span class="line">db_name&#x3D;’baizhan’</span><br><span class="line">backup_dir&#x3D;’&#x2F;data&#x2F;backup&#x2F;mysql&#x2F;‘</span><br><span class="line">current_time&#x3D;$(date +’%Y-%m-%d_%H%M%S’)</span><br><span class="line">filepath&#x3D;$backup_dir$current_time’.sql.gz’</span><br><span class="line">#此处没有使用 $db_password $db_user, 已经写入到配置文件中</span><br><span class="line">echo ‘开始导出数据库…’</span><br><span class="line">mysqldump –defaults-extra-file&#x3D;&#x2F;data&#x2F;backup&#x2F;my_mysql.cnf $db_name | gzip &gt; $filepath</span><br><span class="line">echo ‘导出成功，文件名为: ‘$filepath</span><br></pre></td></tr></table></figure>

<p><code>上面的脚本没有使用到 $db_passoword, 需要的话，大家也可以不用创建配置文件，直接把 -p$db_password -u$db_user拼接到 mysqldupm 命令后面 亲测使用 gzip 命令压缩的话，可以节省 80% 的空间 mysql 5.6以上会提示在命令行输入密码不安全，会有一行 notice ，但是也能导出成功 如果直接使用密码的话，就会报下面这个警告 mysqldump: [Warning] Using a password on the command line interface can be insecure. 解决不报错的办法就是把密码写到配置文件中去，文件内容参考如下，配置文件我们可以在新建一个</code></p>
<p>新建配置文件, 就在我们的当前目录下 即 /data/backup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi my_mysql.cnf</span><br></pre></td></tr></table></figure>

<p>下面的是文件内容，这里可以设置一下允许导出的文件大小上限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqldump] </span><br><span class="line">max_allowed_packet &#x3D; 400M </span><br><span class="line">host&#x3D;127.0.0.1 </span><br><span class="line">user&#x3D;root </span><br><span class="line">password&#x3D;&#39;SgDGfsrfEi3#@%#%ugslp%z!dAP&#39; </span><br><span class="line">[mysql] </span><br><span class="line">host&#x3D;127.0.0.1 </span><br><span class="line">user&#x3D;root </span><br><span class="line">password&#x3D;&#39;SgDGfsrfEi3#@%#%ugslp%z!dAP&#39;</span><br></pre></td></tr></table></figure>

<p><code>各位看官请把上面的参数改成自己的就好了，可别漏了这一步哦 其中 mysqldump 下的参数是给导出的命令使用的，mysql 下的参数是导入的时候使用的</code></p>
<p>到这里的话导出的shell脚本就已经写好了，我们对这个脚本加一下可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x .&#x2F;mysql_backup.sh</span><br></pre></td></tr></table></figure>
<p>现在我们就可以使用下面的命令来导出了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh .&#x2F;mysql_backup.sh</span><br><span class="line">查看一下结果</span><br><span class="line">ll .&#x2F;mysql</span><br></pre></td></tr></table></figure>

<p>到这里为止，我们的导出脚本已经完成了，接下来就是导入脚本了</p>
<h2 id="二、数据恢复"><a href="#二、数据恢复" class="headerlink" title="二、数据恢复"></a>二、数据恢复</h2><ol>
<li>创建脚本文件<br>按照第一步的操作，此时我们应该处于 /data/backup 目录下，继续操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi mysql_restore.sh</span><br></pre></td></tr></table></figure>
粘贴下面的内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">if [ -z $1 ] || [ ! -f $1 ]</span><br><span class="line">then</span><br><span class="line">echo “请输入sql压缩文件(*.sql.gz)”</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">db_name&#x3D;’baizhan’</span><br><span class="line">base_dir&#x3D;’&#x2F;data&#x2F;backup&#x2F;mysql&#x2F;‘</span><br><span class="line">gz_sql_file&#x3D;basename $1</span><br><span class="line"></span><br><span class="line">file_ext&#x3D;$&#123;gz_sql_file##*.&#125;</span><br><span class="line">if [ $file_ext !&#x3D; ‘gz’ ]</span><br><span class="line">then</span><br><span class="line">echo ‘文件格式不正确，请输入 .sql.gz 文件’</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sql_file&#x3D;$&#123;gz_sql_file%.*&#125;</span><br><span class="line">echo ‘解压文件中…’</span><br><span class="line">gzip -dc $base_dir$gz_sql_file &gt; $base_dir$sql_file</span><br><span class="line">echo ‘解压完成.’</span><br><span class="line">echo ‘开始导入数据库…’</span><br><span class="line"></span><br><span class="line">mysql –defaults-extra-file&#x3D;&#x2F;data&#x2F;backup&#x2F;my_mysql.cnf $db_name &lt; $base_dir$sql_file</span><br><span class="line"></span><br><span class="line">if [ -f $base_dir$sql_file ]</span><br><span class="line">then</span><br><span class="line">echo ‘删除临时文件.’</span><br><span class="line">rm -f $base_dir$sql_file</span><br><span class="line">fi</span><br><span class="line">echo ‘导入完成.’</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面代码中的配置文件，就是我们第一步时创建的配置文件，在这里一样的使用</p>
<p>增加文件可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x .&#x2F;mysql_restore.sh</span><br></pre></td></tr></table></figure>

<p>以上就是导入脚本内容，我们来执行一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh .&#x2F;mysql_restore.sh .&#x2F;mysql&#x2F;2018-11-30_223601.sql.gz</span><br></pre></td></tr></table></figure>

<p>在这里我们的第一个参数可以直接写备份文件的名字，不用写目录，但是因为加上目录之后，可以使用table进行自动补全，所以十分方便，<br><code>其实可以在任何文件夹进行恢复，执行 sh /data/backup/mysql_restore.sh /data/backup/mysql/2018-11-30_223601.sql.gz 也可以这样 sh /data/backup/mysql_restore.sh 2018-11-30_223601.sql.gz</code><br>到这里我们的脚本就已经写完了，就剩下创建定时任务来执行了</p>
<h2 id="三、创建计划任务"><a href="#三、创建计划任务" class="headerlink" title="三、创建计划任务"></a>三、创建计划任务</h2><ol>
<li>添加计划任务<br><code>这里并没有教大家怎么使用 crontab, 如果有小伙伴不会的话，搜一下就有答案了</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">粘贴下面的内容， 大家根据自己的需要更改就可以了</span><br><span class="line">0 1,12 * * * &#x2F;data&#x2F;backup&#x2F;mysql_backup.sh # 每天凌晨1点，中午12点备份一次数据</span><br><span class="line">大家可以先使用下面这条做为测试哦，1分钟跑一次，我们只需要查看 ll &#x2F;data&#x2F;backup&#x2F;mysql 这个文件夹就好了</span><br><span class="line">*&#x2F;1 * * * * &#x2F;data&#x2F;backup&#x2F;mysql_backup.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="四、更新，添加自动清理备份"><a href="#四、更新，添加自动清理备份" class="headerlink" title="四、更新，添加自动清理备份"></a>四、更新，添加自动清理备份</h2><ol>
<li>创建删除文件脚本<br>我们还是在/data/backup 目录下面创建脚本，下面就是脚本内容了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi remove_backup.sh</span><br><span class="line">复制下面的脚本内容</span><br><span class="line">#&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">删除30天前的备份</span><br><span class="line">find &#x2F;data&#x2F;backup&#x2F;mysql -type f -mtime +30 | xargs rm -f</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我这里是选择备份数据只保留最近30天的，大家根据需要自行修改<br>同样的道理，添加可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x .&#x2F;remove_backup.sh</span><br><span class="line"></span><br><span class="line">使用下面这个命令可以手动清理哦</span><br><span class="line">.&#x2F;remove_backup.sh</span><br></pre></td></tr></table></figure>

<p>接下来我们就要做到自动清理了，添加到 crontab中，和上一步的自动备份一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">下面这个就是脚本内容哦，添加这一句</span><br><span class="line">0 1 * * * &#x2F;data&#x2F;backup&#x2F;remove_backup.sh # 每天凌晨1点，自动删除30天前的备份</span><br></pre></td></tr></table></figure>

<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>大功告成，以上就是所有的 mysql 自动定时备份和手动恢复脚本了，有疑问的话，欢迎各位评论</p>
]]></content>
  </entry>
  <entry>
    <title>单例模式的五种写法</title>
    <url>/2021/03/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一-懒汉式"><a href="#一-懒汉式" class="headerlink" title="一. 懒汉式"></a>一. 懒汉式</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LHan &#123;  </span><br><span class="line"></span><br><span class="line">    private static LHan instance;  </span><br><span class="line"></span><br><span class="line">    private LHan();  </span><br><span class="line"></span><br><span class="line">    public static LHan getInstance()&#123;  </span><br><span class="line">        if( instance  &#x3D;&#x3D; null )&#123;  </span><br><span class="line">            instance &#x3D; new LHan();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。</p>
<h2 id="二-饿汉式"><a href="#二-饿汉式" class="headerlink" title="二. 饿汉式"></a>二. 饿汉式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EHan&#123;  </span><br><span class="line"></span><br><span class="line">    private static EHan instance &#x3D; new EHan();</span><br><span class="line">    </span><br><span class="line">    private EHan();</span><br><span class="line">    </span><br><span class="line">    public static EHan getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。</p>
<h2 id="三-双检锁"><a href="#三-双检锁" class="headerlink" title="三. 双检锁"></a>三. 双检锁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DoubleCheck&#123;</span><br><span class="line"></span><br><span class="line">    private static DoubleCheck instance;</span><br><span class="line">    </span><br><span class="line">    private DoubleCheck()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    public static DoubleCheck getInstance()&#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null )&#123;</span><br><span class="line">            synchronized (DoubleCheck.class)&#123;</span><br><span class="line">                if( instance &#x3D;&#x3D; null )&#123; </span><br><span class="line">                    instance &#x3D; new DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。</p>
<h2 id="四-静态内部类"><a href="#四-静态内部类" class="headerlink" title="四. 静态内部类"></a>四. 静态内部类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<h2 id="五-枚举"><a href="#五-枚举" class="headerlink" title="五.枚举"></a>五.枚举</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    public void anyMethod()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下，  </p>
<ol>
<li>懒汉式（包含线程安全和线程不安全两种方式）都比较少用；  </li>
<li>饿汉式和双检锁都可以使用，可根据具体情况自主选择；  </li>
<li>在要明确实现 lazy loading 效果时，可以考虑静态内部类的实现方式；  </li>
<li>若涉及到反序列化创建对象时，也可以尝试使用枚举方式。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>测试一下</title>
    <url>/2021/02/26/you-title/</url>
    <content><![CDATA[<p>艳辉神经病</p>
]]></content>
  </entry>
  <entry>
    <title>通过jdk8特性将list&lt;Map&gt;数据拼接</title>
    <url>/2021/02/26/%E9%80%9A%E8%BF%87jdk8%E7%89%B9%E6%80%A7%E5%B0%86list-Map-%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<p>m1为第一个List<Map>集合，m2为第二个，且m1和m2有共同的唯一字段互相绑定</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, Object&gt;&gt; merge(List&lt;Map&lt;String, Object&gt;&gt; m1, List&lt;Map&lt;String, Object&gt;&gt; m2)&#123;</span><br><span class="line"></span><br><span class="line">     m1.addAll(m2);</span><br><span class="line"></span><br><span class="line">     Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> m1.stream()</span><br><span class="line">             .collect(Collectors.groupingBy(o-&gt;&#123;</span><br><span class="line">                 <span class="comment">//暂存所有key</span></span><br><span class="line">                 set.addAll(o.keySet());</span><br><span class="line">                 <span class="comment">//按某个唯一字段进行分组</span></span><br><span class="line">                 <span class="keyword">return</span> o.get(<span class="string">&quot;FLAGSTR&quot;</span>);</span><br><span class="line">             &#125;)).entrySet().stream().map(o-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//合并</span></span><br><span class="line">                 Map&lt;String, Object&gt; map = o.getValue().stream().flatMap(m-&gt;&#123;</span><br><span class="line">                     <span class="keyword">return</span> m.entrySet().stream();</span><br><span class="line">                 &#125;).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a,b)-&gt;b));</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//为没有的key赋值0</span></span><br><span class="line">                 set.stream().forEach(k-&gt;&#123;</span><br><span class="line">                     <span class="keyword">if</span>(!map.containsKey(k)) map.put(k, <span class="number">0</span>);</span><br><span class="line">                 &#125;);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> map;</span><br><span class="line">             &#125;).collect(Collectors.toList());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
